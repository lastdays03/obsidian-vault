---
tags:
  - knowledge/topic
Source: [[GitHub_Study_Python]]
---

# NumPy 라이브러리 완전 가이드

## 📖 정의 (Definition)
**NumPy (Numerical Python)**는 파이썬에서 과학 계산을 위한 핵심 라이브러리입니다. 고성능 다차원 배열 객체와 이를 다루는 도구들을 제공하며, 데이터 분석과 머신러닝의 기초가 됩니다.

---

## 목차

1. [NumPy 소개](#1-numpy-소개)
2. [배열 생성 (Array Creation)](#2-배열-생성-array-creation)
3. [배열 속성 (Array Attributes)](#3-배열-속성-array-attributes)
4. [배열 인덱싱과 슬라이싱](#4-배열-인덱싱과-슬라이싱)
5. [배열 연산 (Array Operations)](#5-배열-연산-array-operations)
6. [배열 변형 (Array Manipulation)](#6-배열-변형-array-manipulation)
7. [배열 결합과 분할](#7-배열-결합과-분할)
8. [통계 함수 (Statistical Functions)](#8-통계-함수-statistical-functions)
9. [선형대수 연산 (Linear Algebra)](#9-선형대수-연산-linear-algebra)
10. [난수 생성 (Random Number Generation)](#10-난수-생성-random-number-generation)
11. [배열 저장 및 로드](#11-배열-저장-및-로드)
12. [유용한 유틸리티 함수](#12-유용한-유틸리티-함수)
13. [실전 예제](#13-실전-예제)
14. [요약](#14-요약)

---

## 1. NumPy 소개

### 1.1 NumPy란?

**NumPy (Numerical Python)**는 파이썬에서 과학 계산을 위한 핵심 라이브러리입니다. 고성능 다차원 배열 객체와 이를 다루는 도구들을 제공합니다.

### 1.2 NumPy의 주요 특징

- **고성능**: C로 구현되어 매우 빠른 연산 속도
- **다차원 배열**: 1차원, 2차원, 3차원 이상의 배열 지원
- **벡터화 연산**: 반복문 없이 배열 전체에 대한 연산 수행
- **브로드캐스팅**: 서로 다른 크기의 배열 간 연산 지원
- **다양한 수학 함수**: 선형대수, 통계, 푸리에 변환 등

### 1.3 설치

```bash
pip install numpy
```

### 1.4 기본 임포트

```python
import numpy as np
```

---

## 2. 배열 생성 (Array Creation)

### 2.1 리스트에서 배열 생성

**설명**: 파이썬 [[01. python_variables_datatypes|리스트]]나 중첩 리스트를 NumPy 배열로 변환합니다. NumPy 배열은 리스트보다 빠른 연산과 다양한 수학 함수를 제공합니다.

**사용 사례**: 
- 데이터 분석 전 리스트를 배열로 변환
- 이미지 데이터 처리 (2D/3D 배열)
- 머신러닝 모델의 입력 데이터 준비

```python
import numpy as np

# 1차원 배열
arr1d = np.array([1, 2, 3, 4, 5])
print(arr1d)  # [1 2 3 4 5]

# 2차원 배열
arr2d = np.array([[1, 2, 3], [4, 5, 6]])
print(arr2d)
# [[1 2 3]
#  [4 5 6]]

# 3차원 배열
arr3d = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
print(arr3d)
# [[[1 2]
#   [3 4]]
#  [[5 6]
#   [7 8]]]
```

### 2.2 특수 배열 생성 함수

#### zeros: 모든 원소가 0인 배열

**설명**: 모든 원소가 0으로 초기화된 배열을 생성합니다. 메모리 할당과 초기화를 한 번에 수행합니다.

**사용 사례**:
- 머신러닝 모델의 가중치 초기화
- 이미지 처리에서 빈 캔버스 생성
- 누적 계산을 위한 초기 배열 생성

```python
# 1차원 배열 (5개 원소)
zeros1d = np.zeros(5)
print(zeros1d)  # [0. 0. 0. 0. 0.]

# 2차원 배열 (3x4)
zeros2d = np.zeros((3, 4))
print(zeros2d)
# [[0. 0. 0. 0.]
#  [0. 0. 0. 0.]
#  [0. 0. 0. 0.]]

# 정수형으로 생성
zeros_int = np.zeros((2, 3), dtype=int)
print(zeros_int)
# [[0 0 0]
#  [0 0 0]]
```

#### ones: 모든 원소가 1인 배열

**설명**: 모든 원소가 1로 초기화된 배열을 생성합니다. 곱셈 연산의 항등원으로 사용됩니다.

**사용 사례**:
- 마스크 생성 (모든 픽셀 활성화)
- 가중치 초기화 (특정 신경망 레이어)
- 단위 행렬 생성의 기초

```python
# 1차원 배열
ones1d = np.ones(5)
print(ones1d)  # [1. 1. 1. 1. 1.]

# 2차원 배열
ones2d = np.ones((2, 3))
print(ones2d)
# [[1. 1. 1.]
#  [1. 1. 1.]]
```

#### empty: 초기화되지 않은 배열 (빠른 생성)

**설명**: 메모리만 할당하고 초기화하지 않은 배열을 생성합니다. 값은 메모리의 기존 내용(랜덤)이므로 바로 덮어써야 합니다. `zeros`보다 빠르지만 주의가 필요합니다.

**사용 사례**:
- 빠른 배열 생성 (초기화 불필요한 경우)
- 대용량 배열 생성 (성능 최적화)
- 즉시 값을 채울 배열 생성
- 메모리 할당만 필요한 경우

```python
# 메모리만 할당하고 초기화하지 않음 (값은 랜덤)
empty_arr = np.empty((2, 3))
print(empty_arr)
```

#### full: 특정 값으로 채운 배열

**설명**: 모든 원소가 지정된 값으로 초기화된 배열을 생성합니다. `zeros`나 `ones`의 일반화된 버전입니다.

**사용 사례**:
- 특정 값으로 초기화된 배열 생성
- 기본값 설정
- 마스크 생성 (특정 값으로 채운 마스크)
- 테스트 데이터 생성
- 상수 행렬 생성

```python
# 7로 채운 3x3 배열
full_arr = np.full((3, 3), 7)
print(full_arr)
# [[7 7 7]
#  [7 7 7]
#  [7 7 7]]
```

#### arange: 범위 배열 생성

**설명**: 지정된 범위와 간격으로 정수 또는 실수 배열을 생성합니다. 파이썬의 `range()`와 유사하지만 배열을 반환합니다.

**사용 사례**:
- 반복문의 인덱스 생성
- 그래프의 x축 좌표 생성
- 데이터 샘플링 인덱스 생성
- 간격이 있는 시퀀스 데이터 생성

```python
# 0부터 9까지
arr1 = np.arange(10)
print(arr1)  # [0 1 2 3 4 5 6 7 8 9]

# 5부터 14까지
arr2 = np.arange(5, 15)
print(arr2)  # [5 6 7 8 9 10 11 12 13 14]

# 0부터 20까지 2씩 증가
arr3 = np.arange(0, 20, 2)
print(arr3)  # [0 2 4 6 8 10 12 14 16 18]

# 실수형
arr4 = np.arange(0, 1, 0.1)
print(arr4)  # [0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9]
```

#### linspace: 균등 간격 배열 생성

**설명**: 시작값과 끝값 사이를 지정된 개수로 균등하게 나눈 배열을 생성합니다. 간격보다 개수를 지정할 때 유용합니다.

**사용 사례**:
- 함수 그래프 그리기 (x축 좌표)
- 신호 처리에서 샘플링 포인트 생성
- 수치 적분/미분을 위한 격자 생성
- 데이터 시각화의 x축 범위 설정

```python
# 0부터 10까지 5개의 균등한 간격
arr1 = np.linspace(0, 10, 5)
print(arr1)  # [ 0.   2.5  5.   7.5 10. ]

# 0부터 1까지 11개 (끝점 포함)
arr2 = np.linspace(0, 1, 11)
print(arr2)  # [0.  0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1. ]

# 끝점 제외
arr3 = np.linspace(0, 1, 11, endpoint=False)
print(arr3)  # [0.         0.09090909 0.18181818 ... 0.90909091]
```

#### logspace: 로그 스케일 배열 생성

**설명**: 로그 스케일로 균등한 간격의 배열을 생성합니다. 지수적으로 증가하는 값들이 필요할 때 사용합니다.

**사용 사례**:
- 주파수 범위 생성 (신호 처리)
- 하이퍼파라미터 탐색 (학습률 등)
- 로그 스케일 그래프의 x축
- 넓은 범위의 값 생성
- 지수적 증가 패턴

```python
# 10^0부터 10^2까지 5개의 균등한 간격
arr = np.logspace(0, 2, 5)
print(arr)  # [  1.          3.16227766  10.          31.6227766  100.        ]
```

#### eye: 단위 행렬 (Identity Matrix)

**설명**: 대각선 원소가 모두 1이고 나머지는 0인 단위 행렬을 생성합니다. 행렬 곱셈의 항등원으로 사용됩니다.

**사용 사례**:
- 선형대수 연산 (항등 행렬)
- 행렬 초기화
- 단위 변환 행렬
- 테스트 및 검증
- 행렬 연산의 기준점

```python
# 3x3 단위 행렬
identity = np.eye(3)
print(identity)
# [[1. 0. 0.]
#  [0. 1. 0.]
#  [0. 0. 1.]]

# 4x5 단위 행렬 (비정사각형)
identity_rect = np.eye(4, 5)
print(identity_rect)
```

#### diag: 대각 행렬

**설명**: 주어진 벡터를 대각선 원소로 하는 대각 행렬을 생성합니다. 또는 기존 행렬에서 대각선 원소를 추출할 수도 있습니다.

**사용 사례**:
- 대각 행렬 생성
- 행렬의 대각선 원소 추출
- 스케일링 행렬 생성
- 선형 변환 (축별 스케일링)
- 행렬 분해

```python
# 대각선 원소만 있는 행렬
diag_arr = np.diag([1, 2, 3, 4])
print(diag_arr)
# [[1 0 0 0]
#  [0 2 0 0]
#  [0 0 3 0]
#  [0 0 0 4]]
```

### 2.3 데이터 타입 지정

**설명**: 배열의 데이터 타입을 명시적으로 지정할 수 있습니다. 메모리 사용량과 연산 정밀도를 제어하는 데 중요합니다.

**사용 사례**:
- 메모리 최적화 (작은 타입 사용)
- 정밀도 제어 (float32 vs float64)
- 다른 시스템과의 호환성
- 성능 최적화
- 데이터 타입 명시적 지정

```python
# dtype 파라미터로 데이터 타입 지정
arr_int = np.array([1, 2, 3], dtype=np.int32)
arr_float = np.array([1, 2, 3], dtype=np.float64)
arr_complex = np.array([1, 2, 3], dtype=np.complex128)
arr_bool = np.array([1, 0, 1], dtype=bool)

print(arr_int.dtype)    # int32
print(arr_float.dtype)  # float64
print(arr_complex.dtype)  # complex128
print(arr_bool.dtype)   # bool
```

---

## 3. 배열 속성 (Array Attributes)

### 3.1 기본 속성

```python
import numpy as np

arr = np.array([[1, 2, 3, 4, 5], [6, 7, 8, 9, 10]])

# shape: 배열의 차원 크기 (행, 열)
print(arr.shape)  # (2, 5)

# dtype: 배열의 데이터 타입
print(arr.dtype)  # int32 또는 int64

# size: 배열의 총 원소 개수
print(arr.size)  # 10

# ndim: 배열의 차원 수
print(arr.ndim)  # 2

# itemsize: 각 원소의 바이트 크기
print(arr.itemsize)  # 4 (int32의 경우)

# nbytes: 배열 전체의 바이트 크기
print(arr.nbytes)  # 40 (10 * 4)

# strides: 각 차원을 따라 이동할 때 필요한 바이트 수
print(arr.strides)  # (20, 4) - 행 이동: 20바이트, 열 이동: 4바이트
```

### 3.2 속성 활용 예제

```python
arr = np.array([1, 2, 3, 4, 5])

print(f"배열: {arr}")
print(f"형태: {arr.shape}")
print(f"데이터 타입: {arr.dtype}")
print(f"원소 개수: {arr.size}")
print(f"차원 수: {arr.ndim}")
print(f"원소 크기: {arr.itemsize} bytes")
print(f"전체 크기: {arr.nbytes} bytes")

# 2차원으로 변환
arr_2d = arr.reshape(5, 1)
print(f"\n변환 후 형태: {arr_2d.shape}")
print(f"변환 후 차원 수: {arr_2d.ndim}")
```

---

## 4. 배열 인덱싱과 슬라이싱

### 4.1 1차원 배열 인덱싱

**설명**: 1차원 배열에서 특정 원소나 범위를 선택하는 방법입니다. 파이썬 리스트와 유사하지만 더 강력한 기능을 제공합니다.

**사용 사례**:
- 특정 원소 접근
- 배열의 일부 추출
- 역순 배열 생성
- 간격을 둔 원소 선택
- 데이터 샘플링

```python
arr = np.array([10, 20, 30, 40, 50])

# 단일 인덱싱
print(arr[0])   # 10
print(arr[2])   # 30
print(arr[-1])  # 50 (마지막 원소)

# 슬라이싱
print(arr[1:4])    # [20 30 40]
print(arr[:3])     # [10 20 30]
print(arr[2:])     # [30 40 50]
print(arr[::2])    # [10 30 50] (2칸씩)
print(arr[::-1])   # [50 40 30 20 10] (역순)
```

### 4.2 2차원 배열 인덱싱

**설명**: 2차원 배열에서 행과 열을 지정하여 원소나 부분 배열을 선택합니다. 행과 열 인덱스를 조합하여 다양한 방식으로 접근할 수 있습니다.

**사용 사례**:
- 행/열 선택
- 부분 행렬 추출
- 이미지 크롭
- 데이터프레임 형태의 데이터 접근
- 행렬 연산을 위한 부분 선택

```python
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# 단일 원소 접근
print(arr[0, 0])  # 1
print(arr[1, 2])  # 6
print(arr[2, 1])  # 8

# 행 접근
print(arr[0])     # [1 2 3] (첫 번째 행)
print(arr[1])     # [4 5 6] (두 번째 행)

# 열 접근
print(arr[:, 0])  # [1 4 7] (첫 번째 열)
print(arr[:, 2])  # [3 6 9] (세 번째 열)

# 부분 배열
print(arr[0:2, 1:3])  # [[2 3] [5 6]]
print(arr[1:, :2])    # [[4 5] [7 8]]
```

### 4.3 불리언 인덱싱 (Boolean Indexing)

**설명**: 조건에 따라 배열의 원소를 선택하는 방법입니다. True/False 마스크를 사용하여 조건을 만족하는 원소만 추출합니다.

**사용 사례**:
- 이상치 제거 (특정 범위 밖의 값 필터링)
- 데이터 필터링 (조건에 맞는 데이터만 선택)
- 이미지 처리에서 특정 픽셀 값 선택
- 통계 분석에서 특정 조건의 데이터 추출

```python
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# 조건에 맞는 원소만 선택
mask = arr > 5
print(mask)  # [False False False False False  True  True  True  True  True]
print(arr[mask])  # [6 7 8 9 10]

# 직접 조건 사용
print(arr[arr > 5])      # [6 7 8 9 10]
print(arr[arr % 2 == 0]) # [2 4 6 8 10] (짝수만)

# 복합 조건
print(arr[(arr > 3) & (arr < 8)])  # [4 5 6 7]
print(arr[(arr < 3) | (arr > 8)])  # [1 2 9 10]
```

### 4.4 팬시 인덱싱 (Fancy Indexing)

**설명**: 정수 배열을 사용하여 여러 원소를 한 번에 선택하는 방법입니다. 인덱스 배열을 사용하여 비연속적인 원소들을 선택할 수 있습니다.

**사용 사례**:
- 비연속적인 원소 선택
- 특정 패턴의 원소 추출
- 대각선 원소 선택
- 복잡한 인덱싱 패턴
- 조건에 따른 선택적 접근

```python
arr = np.array([10, 20, 30, 40, 50, 60, 70, 80])

# 인덱스 배열로 접근
indices = [0, 2, 5, 7]
print(arr[indices])  # [10 30 60 80]

# 2차원 배열
arr2d = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# 행 인덱스와 열 인덱스
row_indices = [0, 2]
col_indices = [1, 2]
print(arr2d[row_indices, col_indices])  # [2 9]

# 메시 그리드로 접근
rows = np.array([0, 1, 2])
cols = np.array([0, 1, 2])
print(arr2d[rows, cols])  # [1 5 9] (대각선 원소)
```

---

## 5. 배열 연산 (Array Operations)

### 5.1 기본 산술 연산

**설명**: 배열 간 또는 배열과 스칼라 간의 산술 연산을 수행합니다. 모든 연산이 원소별(element-wise)로 벡터화되어 빠르게 실행됩니다.

**사용 사례**:
- 데이터 변환 (스케일링, 오프셋)
- 배열 간 계산
- 수학적 연산 (제곱, 제곱근 등)
- 데이터 정규화
- 벡터 연산

```python
arr1 = np.array([1, 2, 3, 4])
arr2 = np.array([5, 6, 7, 8])

# 덧셈
print(arr1 + arr2)  # [6 8 10 12]

# 뺄셈
print(arr2 - arr1)  # [4 4 4 4]

# 곱셈 (원소별)
print(arr1 * arr2)  # [5 12 21 32]

# 나눗셈
print(arr2 / arr1)  # [5. 3. 2.33333333 2.]

# 거듭제곱
print(arr1 ** 2)    # [1 4 9 16]

# 스칼라 연산
print(arr1 + 10)    # [11 12 13 14]
print(arr1 * 2)     # [2 4 6 8]
```

### 5.2 비교 연산

**설명**: 배열 간 또는 배열과 스칼라 간의 비교 연산을 수행합니다. 불리언 배열을 반환하여 조건 검사에 사용됩니다.

**사용 사례**:
- 조건 검사
- 데이터 필터링 (불리언 마스크 생성)
- 동등성 검사
- 범위 검사
- 데이터 품질 검증

```python
arr1 = np.array([1, 2, 3, 4])
arr2 = np.array([2, 2, 3, 5])

print(arr1 == arr2)  # [False  True  True False]
print(arr1 != arr2)  # [True False False True]
print(arr1 < arr2)   # [True False False True]
print(arr1 > arr2)   # [False False False False]
print(arr1 <= arr2)  # [True True True True]
```

### 5.3 논리 연산

**설명**: 불리언 배열에 대한 논리 연산(AND, OR, NOT)을 수행합니다. 복합 조건을 만들 때 사용됩니다.

**사용 사례**:
- 복합 조건 생성
- 여러 조건 결합
- 불리언 마스크 조작
- 조건부 필터링
- 논리 연산

```python
arr1 = np.array([True, True, False, False])
arr2 = np.array([True, False, True, False])

print(np.logical_and(arr1, arr2))  # [True False False False]
print(np.logical_or(arr1, arr2))   # [True True True False]
print(np.logical_not(arr1))        # [False False True True]
```

### 5.4 수학 함수

**설명**: 배열의 각 원소에 수학 함수를 적용합니다. 제곱근, 지수, 로그, 삼각함수 등 다양한 수학 함수를 벡터화하여 빠르게 계산합니다.

**사용 사례**:
- 수학적 변환 (로그 변환, 제곱근 등)
- 신호 처리 (삼각함수)
- 데이터 정규화
- 과학 계산
- 통계 변환

```python
arr = np.array([1, 4, 9, 16, 25])

# 제곱근
print(np.sqrt(arr))  # [1. 2. 3. 4. 5.]

# 지수
print(np.exp([1, 2, 3]))  # [2.71828183 7.3890561 20.08553692]

# 로그
print(np.log([1, 10, 100]))  # [0. 2.30258509 4.60517019]

# 삼각함수
angles = np.array([0, np.pi/2, np.pi])
print(np.sin(angles))  # [0. 1. 0.]

# 절댓값
print(np.abs([-1, -2, 3, -4]))  # [1 2 3 4]

# 올림, 내림, 반올림
arr_float = np.array([1.2, 2.7, 3.5, 4.9])
print(np.ceil(arr_float))   # [2. 3. 4. 5.]
print(np.floor(arr_float))  # [1. 2. 3. 4.]
print(np.round(arr_float))  # [1. 3. 4. 5.]
```

### 5.5 브로드캐스팅 (Broadcasting)

**설명**: 서로 다른 크기의 배열 간 연산을 가능하게 하는 NumPy의 강력한 기능입니다. 작은 배열을 큰 배열의 형태로 자동 확장하여 연산합니다.

**사용 사례**:
- 배열의 모든 원소에 스칼라 연산 (정규화, 스케일링)
- 이미지 처리에서 각 픽셀에 값 추가/곱하기
- 머신러닝에서 배치 데이터 처리
- 행/열별로 다른 값 적용 (정규화, 평균 빼기)

```python
# 서로 다른 크기의 배열 간 연산
arr = np.array([[1, 2, 3], [4, 5, 6]])

# 스칼라 브로드캐스팅
print(arr + 10)
# [[11 12 13]
#  [14 15 16]]

# 1차원 배열 브로드캐스팅
row = np.array([10, 20, 30])
print(arr + row)
# [[11 22 33]
#  [14 25 36]]

# 열 벡터 브로드캐스팅
col = np.array([[10], [20]])
print(arr + col)
# [[11 12 13]
#  [24 25 26]]
```

---

## 6. 배열 변형 (Array Manipulation)

### 6.1 reshape: 배열 형태 변경

**설명**: 배열의 형태를 변경하지만 데이터는 유지합니다. 메모리를 재할당하지 않고 뷰를 반환하므로 효율적입니다.

**사용 사례**:
- 이미지 데이터 형태 변환 (1D → 2D, 2D → 3D)
- 머신러닝 모델 입력 형태 맞추기
- 데이터 전처리 (배치 형태로 변환)
- 행렬 연산을 위한 형태 조정

```python
arr = np.arange(12)

# 3x4 배열로 변환
arr_2d = arr.reshape(3, 4)
print(arr_2d)
# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]]

# -1 사용 (자동 계산)
arr_3d = arr.reshape(2, 2, -1)  # 마지막 차원은 자동 계산
print(arr_3d.shape)  # (2, 2, 3)

# 1차원으로 변환
arr_flat = arr_2d.reshape(-1)
print(arr_flat)  # [ 0  1  2  3  4  5  6  7  8  9 10 11]
```

### 6.2 flatten과 ravel: 1차원으로 변환

```python
arr = np.array([[1, 2, 3], [4, 5, 6]])

# flatten: 새로운 배열 반환
flattened = arr.flatten()
print(flattened)  # [1 2 3 4 5 6]

# ravel: 가능하면 뷰 반환 (더 효율적)
raveled = arr.ravel()
print(raveled)  # [1 2 3 4 5 6]
```

#### flatten과 ravel의 차이점

**flatten()**과 **ravel()**은 모두 다차원 배열을 1차원으로 변환하지만, 중요한 차이점이 있습니다:

1. **반환 방식**:
   - `flatten()`: 항상 **복사본(copy)**을 반환합니다.
   - `ravel()`: 가능하면 **뷰(view)**를 반환하고, 불가능한 경우에만 복사본을 반환합니다.

2. **메모리 효율성**:
   - `flatten()`: 항상 새로운 메모리를 할당하므로 메모리 사용량이 더 큽니다.
   - `ravel()`: 뷰를 반환할 경우 원본 배열과 메모리를 공유하므로 더 효율적입니다.

3. **원본 배열과의 관계**:
   - `flatten()`: 반환된 배열을 수정해도 원본 배열에 영향을 주지 않습니다.
   - `ravel()`: 뷰를 반환한 경우, 반환된 배열을 수정하면 원본 배열도 함께 변경됩니다.

```python
arr = np.array([[1, 2, 3], [4, 5, 6]])

# flatten 사용
flattened = arr.flatten()
flattened[0] = 999
print(arr)        # [[1 2 3] [4 5 6]] (원본 변경 안 됨)
print(flattened)  # [999 2 3 4 5 6]

# ravel 사용
raveled = arr.ravel()
raveled[0] = 888
print(arr)        # [[888 2 3] [4 5 6]] (원본도 변경됨!)
print(raveled)    # [888 2 3 4 5 6]

# ravel이 복사본을 반환하는 경우 (Fortran 순서 등)
arr_f = np.array([[1, 2, 3], [4, 5, 6]], order='F')
raveled_f = arr_f.ravel()
print(raveled_f.base is None)  # True (복사본이므로 base가 None)
```

**언제 사용할까?**
- `flatten()`: 원본 배열과 독립적인 배열이 필요할 때 사용
- `ravel()`: 메모리 효율성이 중요하고, 원본과 연결되어도 괜찮을 때 사용

### 6.3 transpose와 T: 전치 행렬

**설명**: 행과 열을 바꾸는 전치(transpose) 연산입니다. 행렬의 행이 열로, 열이 행으로 변환됩니다. `.T` 속성과 `transpose()` 함수는 동일한 결과를 반환합니다.

**사용 사례**:
- 선형대수 연산 (행렬 곱셈 전 형태 조정)
- 데이터 전처리 (행/열 방향 변경)
- 이미지 처리 (회전, 변환)
- 머신러닝 (특성 행렬 변환)
- 데이터 시각화 (행/열 방향 변경)

```python
arr = np.array([[1, 2, 3], [4, 5, 6]])
print(arr)
# [[1 2 3]
#  [4 5 6]]

# 전치 행렬
print(arr.T)
# [[1 4]
#  [2 5]
#  [3 6]]

# transpose 함수 사용
print(np.transpose(arr))
# [[1 4]
#  [2 5]
#  [3 6]]
```

### 6.4 expand_dims와 squeeze: 차원 추가/제거

**설명**: 배열의 차원을 추가하거나 제거하는 함수입니다. `expand_dims`는 지정된 위치에 크기가 1인 차원을 추가하고, `squeeze`는 크기가 1인 차원을 제거합니다.

**사용 사례**:
- 머신러닝 모델 입력 형태 맞추기 (배치 차원 추가)
- 브로드캐스팅을 위한 차원 조정
- 이미지 처리 (채널 차원 추가/제거)
- 데이터 전처리 (형태 변환)
- 신경망 레이어 입력/출력 형태 조정

```python
arr = np.array([1, 2, 3, 4])

# 차원 추가
arr_2d = np.expand_dims(arr, axis=0)  # 행 차원 추가
print(arr_2d.shape)  # (1, 4)

arr_col = np.expand_dims(arr, axis=1)  # 열 차원 추가
print(arr_col.shape)  # (4, 1)

# 차원 제거
arr_squeezed = np.squeeze(arr_2d)
print(arr_squeezed.shape)  # (4,)
```

### 6.5 swapaxes: 축 교환

**설명**: 배열의 두 축을 교환합니다. 3차원 이상의 배열에서 특정 차원의 순서를 변경할 때 사용합니다.

**사용 사례**:
- 이미지 데이터 형태 변환 (높이, 너비, 채널 순서 변경)
- 텐서 연산 (차원 순서 재배열)
- 데이터 전처리 (차원 순서 조정)
- 딥러닝 프레임워크 간 데이터 변환
- 다차원 배열 재구성

```python
arr = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])
print(arr.shape)  # (2, 2, 2)

# 축 0과 1 교환
swapped = np.swapaxes(arr, 0, 1)
print(swapped.shape)  # (2, 2, 2)
```

---

## 7. 배열 결합과 분할

### 7.1 배열 결합

#### concatenate: 배열 연결

**설명**: 여러 배열을 지정된 축(axis) 방향으로 연결합니다. 가장 일반적인 배열 결합 방법입니다.

**사용 사례**:
- 여러 데이터셋 결합
- 배치 데이터 생성
- 특성(feature) 배열 결합
- 시계열 데이터 연결
- 이미지 패치 결합

```python
arr1 = np.array([[1, 2], [3, 4]])
arr2 = np.array([[5, 6], [7, 8]])

# 행 방향 연결 (axis=0)
result = np.concatenate([arr1, arr2], axis=0)
print(result)
# [[1 2]
#  [3 4]
#  [5 6]
#  [7 8]]

# 열 방향 연결 (axis=1)
result = np.concatenate([arr1, arr2], axis=1)
print(result)
# [[1 2 5 6]
#  [3 4 7 8]]
```

#### vstack과 hstack: 수직/수평 스택

**설명**: 1차원 배열을 2차원으로 스택하는 함수입니다. `vstack`은 수직(행 방향), `hstack`은 수평(열 방향)으로 결합합니다.

**사용 사례**:
- 1차원 배열을 2차원으로 변환
- 여러 벡터를 행렬로 결합
- 데이터 행 추가/열 추가
- 특성 벡터 결합
- 간단한 배열 결합 (concatenate보다 직관적)

```python
arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])

# 수직 스택 (행 방향)
v_result = np.vstack([arr1, arr2])
print(v_result)
# [[1 2 3]
#  [4 5 6]]

# 수평 스택 (열 방향)
h_result = np.hstack([arr1, arr2])
print(h_result)  # [1 2 3 4 5 6]
```

#### column_stack과 row_stack

**설명**: 1차원 배열을 열 또는 행으로 스택합니다. `column_stack`은 각 배열을 열로, `row_stack`은 각 배열을 행으로 배치합니다.

**사용 사례**:
- 여러 변수를 열로 결합 (특성 행렬 생성)
- 데이터프레임 형태의 배열 생성
- 좌표 데이터 결합 (x, y 좌표)
- 실험 데이터 정리
- 특성 벡터를 열로 배치

```python
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

# 열로 스택
col_result = np.column_stack([a, b])
print(col_result)
# [[1 4]
#  [2 5]
#  [3 6]]

# 행으로 스택
row_result = np.row_stack([a, b])
print(row_result)
# [[1 2 3]
#  [4 5 6]]
```

### 7.2 배열 분할

#### split: 배열 분할

**설명**: 배열을 지정된 개수로 균등하게 분할합니다. 지정된 축(axis) 방향으로 분할되며, 균등하게 나눌 수 있어야 합니다.

**사용 사례**:
- 데이터셋을 여러 부분으로 분할
- 교차 검증을 위한 데이터 분할
- 배치 데이터 분할
- 이미지 패치 분할
- 훈련/검증 데이터 분리

```python
arr = np.arange(12).reshape(3, 4)
print(arr)
# [[ 0  1  2  3]
#  [ 4  5  6  7]
#  [ 8  9 10 11]]

# 행 방향 분할
result = np.split(arr, 3, axis=0)  # 3개로 분할
for i, r in enumerate(result):
    print(f"Part {i}:")
    print(r)

# 열 방향 분할
result = np.split(arr, 2, axis=1)  # 2개로 분할
for i, r in enumerate(result):
    print(f"Part {i}:")
    print(r)
```

#### vsplit과 hsplit: 수직/수평 분할

**설명**: 2차원 배열을 수직(행 방향) 또는 수평(열 방향)으로 분할합니다. `vsplit`은 행을 기준으로, `hsplit`은 열을 기준으로 분할합니다.

**사용 사례**:
- 이미지를 여러 부분으로 분할
- 데이터를 행/열 단위로 분리
- 특성과 레이블 분리
- 데이터 전처리 (부분 데이터 추출)
- 간단한 배열 분할 (split보다 직관적)

```python
arr = np.arange(12).reshape(3, 4)

# 수직 분할 (행 방향)
v_parts = np.vsplit(arr, 3)
for part in v_parts:
    print(part)

# 수평 분할 (열 방향)
h_parts = np.hsplit(arr, 2)
for part in h_parts:
    print(part)
```

#### array_split: 균등하지 않은 분할

**설명**: 배열을 지정된 개수로 분할하되, 균등하게 나눌 수 없어도 가능합니다. 마지막 부분은 더 작을 수 있습니다.

**사용 사례**:
- 데이터를 균등하지 않게 분할
- 교차 검증 (K-fold)
- 배치 크기가 다른 데이터 분할
- 남은 데이터 처리
- 유연한 데이터 분할

```python
arr = np.arange(10)

# 3개로 분할 (균등하지 않아도 됨)
parts = np.array_split(arr, 3)
for i, part in enumerate(parts):
    print(f"Part {i}: {part}")
```

---

## 8. 통계 함수 (Statistical Functions)

### 8.1 기본 통계 함수

**설명**: 배열의 통계적 특성을 계산하는 함수들입니다. 데이터 분석과 탐색적 데이터 분석(EDA)에 필수적입니다.

**사용 사례**:
- 데이터 요약 통계 계산 (평균, 표준편차)
- 이상치 탐지 (평균 ± 표준편차 범위)
- 데이터 정규화 (평균, 분산 사용)
- 최적값 찾기 (최댓값/최솟값 및 인덱스)
- 데이터 품질 검사

```python
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# 합계
print(np.sum(arr))  # 55

# 평균
print(np.mean(arr))  # 5.5

# 중앙값
print(np.median(arr))  # 5.5

# 표준편차
print(np.std(arr))  # 2.8722813232690143

# 분산
print(np.var(arr))  # 8.25

# 최솟값, 최댓값
print(np.min(arr))  # 1
print(np.max(arr))  # 10

# 최솟값, 최댓값의 인덱스
print(np.argmin(arr))  # 0
print(np.argmax(arr))  # 9
```

### 8.2 2차원 배열 통계

**설명**: 2차원 이상의 배열에서 특정 축(axis)을 따라 통계를 계산합니다. axis=0은 열 방향, axis=1은 행 방향입니다.

**사용 사례**:
- 행별/열별 통계 계산
- 데이터프레임 형태의 데이터 분석
- 이미지 처리 (픽셀별 통계)
- 배치 데이터 집계
- 다차원 데이터 요약

```python
arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])

# 전체 합계
print(np.sum(arr))  # 45

# 각 행의 합계 (axis=1)
print(np.sum(arr, axis=1))  # [6 15 24]

# 각 열의 합계 (axis=0)
print(np.sum(arr, axis=0))  # [12 15 18]

# 각 행의 평균
print(np.mean(arr, axis=1))  # [2. 5. 8.]

# 각 열의 평균
print(np.mean(arr, axis=0))  # [4. 5. 6.]
```

### 8.3 백분위수와 사분위수

**설명**: 데이터의 분포를 이해하기 위한 백분위수와 사분위수를 계산합니다. 중앙값, 사분위수 범위(IQR) 등을 구할 수 있습니다.

**사용 사례**:
- 이상치 탐지 (IQR 방법)
- 데이터 분포 분석
- 박스 플롯 생성
- 통계적 요약
- 데이터 품질 검사

```python
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# 25%, 50%, 75% 백분위수
print(np.percentile(arr, [25, 50, 75]))  # [3.25 5.5 7.75]

# 사분위수 범위 (IQR)
q75, q25 = np.percentile(arr, [75, 25])
iqr = q75 - q25
print(iqr)  # 4.5
```

### 8.4 누적 연산

**설명**: 배열의 원소들을 순차적으로 누적하여 계산합니다. 각 위치에서 이전까지의 합이나 곱을 계산합니다.

**사용 사례**:
- 누적 합/곱 계산
- 이동 평균 계산
- 누적 분포 함수
- 시간별 누적 데이터
- 재무 분석 (누적 수익률)

```python
arr = np.array([1, 2, 3, 4, 5])

# 누적 합
print(np.cumsum(arr))  # [1 3 6 10 15]

# 누적 곱
print(np.cumprod(arr))  # [1 2 6 24 120]
```

---

## 9. 선형대수 연산 (Linear Algebra)

### 9.1 행렬 곱셈

**설명**: 두 행렬의 곱셈을 수행합니다. `@` 연산자나 `dot()` 함수를 사용하며, 첫 번째 행렬의 열 수와 두 번째 행렬의 행 수가 같아야 합니다.

**사용 사례**:
- 선형 변환
- 신경망의 선형 레이어 계산
- 데이터 변환 (특성 변환)
- 선형 회귀 (최소제곱법)
- 그래프 이론 (인접 행렬 연산)

```python
arr1 = np.array([[1, 2], [3, 4]])
arr2 = np.array([[5, 6], [7, 8]])

# 행렬 곱셈 (@ 연산자 또는 dot 함수)
result1 = arr1 @ arr2
result2 = np.dot(arr1, arr2)
print(result1)
# [[19 22]
#  [43 50]]
```

### 9.2 내적과 외적

**설명**: 벡터의 내적과 외적을 계산합니다. 내적은 스칼라를, 외적은 벡터를 반환합니다. 3차원 벡터에 주로 사용됩니다.

**사용 사례**:
- 벡터의 유사도 계산 (내적)
- 각도 계산 (내적)
- 수직 벡터 찾기 (외적)
- 물리 시뮬레이션 (토크, 각운동량)
- 컴퓨터 그래픽스 (법선 벡터)

```python
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])

# 내적 (dot product)
dot_product = np.dot(a, b)
print(dot_product)  # 32

# 외적 (cross product)
cross_product = np.cross(a, b)
print(cross_product)  # [-3 6 -3]
```

### 9.3 행렬의 역행렬

**설명**: 정사각 행렬의 역행렬을 계산합니다. 역행렬이 존재하려면 행렬식이 0이 아니어야 합니다. 선형 방정식 풀이에 사용됩니다.

**사용 사례**:
- 선형 방정식 풀이 (Ax = b → x = A^(-1)b)
- 좌표 변환의 역변환
- 선형 회귀 (정규 방정식)
- 행렬 분해
- 수치 해석

```python
arr = np.array([[1, 2], [3, 4]])

# 역행렬
inv_arr = np.linalg.inv(arr)
print(inv_arr)
# [[-2.   1. ]
#  [ 1.5 -0.5]]

# 원래 행렬과 곱하면 단위 행렬
result = arr @ inv_arr
print(result)
# [[1. 0.]
#  [0. 1.]]
```

### 9.4 행렬식 (Determinant)

**설명**: 정사각 행렬의 행렬식을 계산합니다. 행렬식이 0이면 역행렬이 존재하지 않으며, 행렬의 특성을 나타내는 중요한 값입니다.

**사용 사례**:
- 역행렬 존재 여부 확인
- 선형 독립성 판단
- 면적/부피 계산 (변환 행렬)
- 고유값 계산
- 선형 변환의 스케일 팩터

```python
arr = np.array([[1, 2], [3, 4]])

det = np.linalg.det(arr)
print(det)  # -2.0
```

### 9.5 고유값과 고유벡터

**설명**: 행렬의 고유값과 고유벡터를 계산합니다. 고유값 분해는 행렬의 특성을 이해하고 차원 축소 등에 사용됩니다.

**사용 사례**:
- 주성분 분석 (PCA)
- 차원 축소
- 행렬 대각화
- 동적 시스템 분석
- 이미지 압축
- 데이터 분석 (주요 방향 찾기)

```python
arr = np.array([[1, 2], [2, 1]])

eigenvalues, eigenvectors = np.linalg.eig(arr)
print("고유값:", eigenvalues)  # [ 3. -1.]
print("고유벡터:")
print(eigenvectors)
```

### 9.6 선형 방정식 풀이

**설명**: Ax = b 형태의 선형 방정식 시스템을 풉니다. 역행렬을 직접 계산하는 것보다 효율적이고 수치적으로 안정적입니다.

**사용 사례**:
- 선형 회귀 (최소제곱법)
- 회로 분석
- 구조 해석
- 최적화 문제
- 수치 해석
- 물리 시뮬레이션

```python
# Ax = b 형태의 선형 방정식
A = np.array([[3, 1], [1, 2]])
b = np.array([9, 8])

# x = A^(-1) * b
x = np.linalg.solve(A, b)
print(x)  # [2. 3.]
```

---

## 10. 난수 생성 (Random Number Generation)

### 10.1 기본 난수 생성

**설명**: 0과 1 사이의 실수 난수나 지정된 범위의 정수 난수를 생성합니다. 시뮬레이션, 테스트 데이터 생성 등에 사용됩니다.

**사용 사례**:
- 테스트 데이터 생성
- 시뮬레이션 (몬테카를로 방법)
- 머신러닝 가중치 초기화
- 데이터 증강 (augmentation)
- 랜덤 샘플링

```python
# 0과 1 사이의 난수
random_num = np.random.random()
print(random_num)

# 0과 1 사이의 난수 배열
random_arr = np.random.random((3, 3))
print(random_arr)

# 정수 난수 (0 이상 10 미만)
random_int = np.random.randint(0, 10)
print(random_int)

# 정수 난수 배열
random_int_arr = np.random.randint(0, 10, size=(3, 3))
print(random_int_arr)
```

### 10.2 정규 분포 난수

**설명**: 정규 분포(가우시안 분포)를 따르는 난수를 생성합니다. 평균과 표준편차를 지정할 수 있습니다.

**사용 사례**:
- 통계 시뮬레이션
- 머신러닝 가중치 초기화
- 노이즈 추가 (데이터 증강)
- 통계 테스트
- 자연 현상 모델링

```python
# 평균 0, 표준편차 1인 정규 분포
normal_arr = np.random.normal(0, 1, size=(3, 3))
print(normal_arr)

# 평균 5, 표준편차 2인 정규 분포
normal_arr2 = np.random.normal(5, 2, size=10)
print(normal_arr2)
```

### 10.3 균등 분포 난수

**설명**: 지정된 범위에서 균등하게 분포된 난수를 생성합니다. 모든 값이 동일한 확률로 선택됩니다.

**사용 사례**:
- 균등한 샘플링
- 랜덤 초기화
- 테스트 데이터 생성
- 게임 개발 (랜덤 이벤트)
- 공정한 랜덤 선택

```python
# 0과 1 사이의 균등 분포
uniform_arr = np.random.uniform(0, 1, size=10)
print(uniform_arr)

# 5와 10 사이의 균등 분포
uniform_arr2 = np.random.uniform(5, 10, size=10)
print(uniform_arr2)
```

### 10.4 기타 분포

**설명**: 다양한 확률 분포를 따르는 난수를 생성합니다. 이항, 포아송, 지수 분포 등 통계학에서 자주 사용되는 분포들을 지원합니다.

**사용 사례**:
- 통계 모델링 (이항 분포: 성공/실패)
- 이벤트 발생 시뮬레이션 (포아송 분포: 희귀 사건)
- 대기 시간 모델링 (지수 분포: 대기 시간)
- 통계 테스트
- 현실적인 데이터 생성

```python
# 이항 분포
binomial = np.random.binomial(10, 0.5, size=10)
print(binomial)

# 포아송 분포
poisson = np.random.poisson(5, size=10)
print(poisson)

# 지수 분포
exponential = np.random.exponential(2, size=10)
print(exponential)
```

### 10.5 시드 설정

**설명**: 난수 생성기의 시드를 설정하여 동일한 난수 시퀀스를 재현할 수 있게 합니다. 실험의 재현성을 보장하는 데 중요합니다.

**사용 사례**:
- 실험 재현성 보장
- 디버깅 (동일한 난수로 문제 재현)
- 테스트 코드 (예측 가능한 결과)
- 논문/연구 (재현 가능한 결과)
- 머신러닝 모델 학습 (일관된 초기화)

```python
# 재현 가능한 난수 생성을 위한 시드 설정
np.random.seed(42)
arr1 = np.random.random(5)
print(arr1)

np.random.seed(42)  # 같은 시드로 다시 생성
arr2 = np.random.random(5)
print(arr2)  # arr1과 동일한 값
```

### 10.6 배열 섞기

**설명**: 배열의 원소를 무작위로 섞습니다. `shuffle`은 원본을 수정하고, `permutation`은 새로운 배열을 반환합니다.

**사용 사례**:
- 데이터셋 섞기 (훈련 전)
- 교차 검증 (데이터 순서 섞기)
- 랜덤 샘플링
- 게임 개발 (카드 섞기 등)
- 데이터 순서 무작위화

```python
arr = np.arange(10)
print(arr)  # [0 1 2 3 4 5 6 7 8 9]

# 배열 섞기 (in-place)
np.random.shuffle(arr)
print(arr)  # [랜덤 순서]

# 섞인 배열 반환 (원본 유지)
arr = np.arange(10)
shuffled = np.random.permutation(arr)
print(arr)      # [0 1 2 3 4 5 6 7 8 9] (원본 유지)
print(shuffled) # [랜덤 순서]
```

---

## 11. 배열 저장 및 로드

### 11.1 텍스트 파일로 저장/로드

**설명**: 배열을 텍스트 파일(CSV, TXT 등)로 저장하고 로드합니다. 사람이 읽을 수 있는 형식으로 저장되며, 다른 프로그램과 데이터 교환이 쉽습니다.

**사용 사례**:
- 데이터 저장 및 공유
- Excel 등 다른 프로그램과 호환
- 로그 데이터 저장
- 설정 파일 저장
- 간단한 데이터 백업

```python
arr = np.array([[1, 2, 3], [4, 5, 6]])

# 저장
np.savetxt('array.txt', arr)

# 로드
loaded = np.loadtxt('array.txt')
print(loaded)

# 구분자 지정
np.savetxt('array.csv', arr, delimiter=',')
loaded_csv = np.loadtxt('array.csv', delimiter=',')
```

### 11.2 바이너리 파일로 저장/로드

**설명**: 배열을 바이너리 형식(.npy, .npz)으로 저장하고 로드합니다. 텍스트 파일보다 빠르고 메모리 효율적이며, 배열의 모든 정보(형태, 타입 등)를 보존합니다.

**사용 사례**:
- 대용량 데이터 저장 (빠른 로드)
- 모델 가중치 저장
- 중간 결과 저장
- 데이터 백업
- 여러 배열을 한 파일에 저장

```python
arr = np.array([[1, 2, 3], [4, 5, 6]])

# .npy 형식으로 저장 (단일 배열)
np.save('array.npy', arr)
loaded = np.load('array.npy')
print(loaded)

# .npz 형식으로 저장 (여러 배열)
arr1 = np.array([1, 2, 3])
arr2 = np.array([4, 5, 6])
np.savez('arrays.npz', arr1=arr1, arr2=arr2)

# 로드
data = np.load('arrays.npz')
print(data['arr1'])
print(data['arr2'])
```

---

## 12. 유용한 유틸리티 함수

### 12.1 where: 조건부 선택

**설명**: 조건에 따라 배열의 원소를 선택하거나 다른 값으로 대체합니다. 삼항 연산자와 유사하지만 배열 전체에 벡터화되어 적용됩니다.

**사용 사례**:
- 조건에 따른 값 대체 (임계값 이상/이하 처리)
- 데이터 클리핑 (범위 밖 값 제한)
- 이진 분류 (조건에 따라 0/1 할당)
- 이상치 처리 (특정 범위 밖 값 수정)

```python
arr = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])

# 조건이 True면 원래 값, False면 0
result = np.where(arr > 5, arr, 0)
print(result)  # [0 0 0 0 0 6 7 8 9 10]

# 조건에 따라 다른 값 선택
result = np.where(arr % 2 == 0, '짝수', '홀수')
print(result)
```

### 12.2 unique: 고유값 찾기

**설명**: 배열에서 중복을 제거한 고유값을 찾습니다. 정렬된 순서로 반환되며, 각 값의 개수도 함께 반환할 수 있습니다.

**사용 사례**:
- 카테고리 값 추출
- 중복 제거
- 빈도수 계산
- 데이터 품질 검사 (예상 값 확인)
- 레이블 목록 생성

```python
arr = np.array([1, 2, 2, 3, 3, 3, 4, 5])

# 고유값
unique_vals = np.unique(arr)
print(unique_vals)  # [1 2 3 4 5]

# 고유값과 개수
unique_vals, counts = np.unique(arr, return_counts=True)
print(unique_vals)  # [1 2 3 4 5]
print(counts)       # [1 2 3 1 1]
```

### 12.3 sort: 정렬

**설명**: 배열을 정렬합니다. `np.sort()`는 정렬된 새 배열을 반환하고, `.sort()` 메서드는 원본 배열을 정렬합니다.

**사용 사례**:
- 데이터 정렬
- 순위 매기기
- 상위 N개 선택
- 데이터 전처리
- 시각화 전 정렬

```python
arr = np.array([3, 1, 4, 1, 5, 9, 2, 6])

# 정렬된 배열 반환 (원본 유지)
sorted_arr = np.sort(arr)
print(sorted_arr)  # [1 1 2 3 4 5 6 9]
print(arr)         # [3 1 4 1 5 9 2 6] (원본 유지)

# 원본 배열 정렬 (in-place)
arr.sort()
print(arr)  # [1 1 2 3 4 5 6 9]

# 역순 정렬
arr = np.array([3, 1, 4, 1, 5, 9, 2, 6])
sorted_desc = np.sort(arr)[::-1]
print(sorted_desc)  # [9 6 5 4 3 2 1 1]
```

### 12.4 argsort: 정렬 인덱스

**설명**: 배열을 정렬했을 때의 인덱스를 반환합니다. 원본 배열을 변경하지 않고 정렬 순서를 알 수 있습니다.

**사용 사례**:
- 다른 배열을 같은 순서로 정렬
- 상위 N개 인덱스 찾기
- 순위 매기기
- 정렬 기준으로 다른 데이터 접근
- 인덱스 기반 정렬

```python
arr = np.array([3, 1, 4, 1, 5, 9, 2, 6])

# 정렬된 인덱스
indices = np.argsort(arr)
print(indices)  # [1 3 6 0 2 4 7 5]

# 인덱스로 정렬된 배열 얻기
sorted_arr = arr[indices]
print(sorted_arr)  # [1 1 2 3 4 5 6 9]
```

### 12.5 searchsorted: 정렬된 배열에 삽입 위치 찾기

**설명**: 정렬된 배열에서 값을 삽입했을 때의 인덱스 위치를 찾습니다. 이진 검색을 사용하여 효율적으로 동작합니다.

**사용 사례**:
- 정렬된 배열에 값 삽입
- 히스토그램 구간 찾기
- 데이터 분류 (구간별 분류)
- 이진 검색
- 정렬된 데이터에 값 추가

```python
arr = np.array([1, 3, 5, 7, 9])

# 값이 삽입되어야 할 인덱스
idx = np.searchsorted(arr, 4)
print(idx)  # 2 (4는 인덱스 2 위치에 삽입)

idx = np.searchsorted(arr, [2, 4, 6, 8])
print(idx)  # [1 2 3 4]
```

### 12.6 meshgrid: 좌표 그리드 생성

**설명**: 1차원 좌표 배열로부터 2차원 좌표 그리드를 생성합니다. 3D 플롯이나 함수의 2D 그래프를 그릴 때 사용됩니다.

**사용 사례**:
- 3D 표면 그래프 그리기
- 등고선 그래프 (contour plot)
- 2D 함수 시각화
- 좌표 변환
- 이미지 처리 (픽셀 좌표)

```python
x = np.linspace(0, 5, 6)
y = np.linspace(0, 5, 6)

X, Y = np.meshgrid(x, y)
print(X)
# [[0. 1. 2. 3. 4. 5.]
#  [0. 1. 2. 3. 4. 5.]
#  ...]

print(Y)
# [[0. 0. 0. 0. 0. 0.]
#  [1. 1. 1. 1. 1. 1.]
#  ...]
```

### 12.7 tile과 repeat: 배열 반복

**설명**: 배열을 반복하여 확장합니다. `tile`은 배열 전체를 반복하고, `repeat`은 각 원소를 반복합니다.

**사용 사례**:
- 패턴 생성 (배열 반복)
- 테스트 데이터 생성
- 이미지 타일링
- 데이터 증강
- 배열 확장

```python
arr = np.array([1, 2, 3])

# tile: 배열 전체를 반복
tiled = np.tile(arr, 3)
print(tiled)  # [1 2 3 1 2 3 1 2 3]

# 2차원으로 타일링
tiled_2d = np.tile(arr, (2, 3))
print(tiled_2d)
# [[1 2 3 1 2 3 1 2 3]
#  [1 2 3 1 2 3 1 2 3]]

# repeat: 각 원소를 반복
repeated = np.repeat(arr, 3)
print(repeated)  # [1 1 1 2 2 2 3 3 3]
```

---

## 13. 실전 예제

### 13.1 이미지 데이터 처리 시뮬레이션

```python
# 이미지를 2D 배열로 시뮬레이션 (그레이스케일)
image = np.random.randint(0, 256, size=(100, 100), dtype=np.uint8)

# 이미지 밝기 조정
brightened = np.clip(image + 50, 0, 255)

# 이미지 크롭
cropped = image[20:80, 20:80]

# 이미지 회전 (90도)
rotated = np.rot90(image)

# 이미지 평균값
mean_brightness = np.mean(image)
print(f"평균 밝기: {mean_brightness}")
```

### 13.2 데이터 정규화

```python
# 원본 데이터
data = np.random.normal(100, 15, size=1000)

# Z-score 정규화 (평균 0, 표준편차 1)
normalized = (data - np.mean(data)) / np.std(data)
print(f"정규화 후 평균: {np.mean(normalized):.6f}")
print(f"정규화 후 표준편차: {np.std(normalized):.6f}")

# Min-Max 정규화 (0~1 범위)
min_max_norm = (data - np.min(data)) / (np.max(data) - np.min(data))
print(f"Min-Max 정규화 범위: [{np.min(min_max_norm):.6f}, {np.max(min_max_norm):.6f}]")
```

### 13.3 행렬 연산을 이용한 선형 회귀

```python
# 간단한 선형 회귀 예제
# y = 2x + 1 + noise

x = np.linspace(0, 10, 100)
y = 2 * x + 1 + np.random.normal(0, 1, 100)

# 최소제곱법으로 회귀 계수 계산
A = np.vstack([x, np.ones(len(x))]).T
m, c = np.linalg.lstsq(A, y, rcond=None)[0]

print(f"기울기: {m:.2f} (실제: 2.0)")
print(f"절편: {c:.2f} (실제: 1.0)")
```

### 13.4 데이터 필터링

```python
# 온도 데이터
temperatures = np.array([20, 22, 25, 18, 30, 15, 28, 23, 19, 27])

# 이상치 제거 (평균 ± 2*표준편차 범위 내)
mean_temp = np.mean(temperatures)
std_temp = np.std(temperatures)
lower_bound = mean_temp - 2 * std_temp
upper_bound = mean_temp + 2 * std_temp

filtered = temperatures[(temperatures >= lower_bound) & (temperatures <= upper_bound)]
print(f"원본: {temperatures}")
print(f"필터링 후: {filtered}")
```

### 13.5 배열 병합과 분할 실전 예제

```python
# 여러 센서 데이터를 하나로 합치기
sensor1 = np.random.normal(0, 1, size=100)
sensor2 = np.random.normal(0, 1, size=100)
sensor3 = np.random.normal(0, 1, size=100)

# 열 방향으로 결합 (각 센서가 하나의 열)
all_sensors = np.column_stack([sensor1, sensor2, sensor3])
print(f"결합된 데이터 형태: {all_sensors.shape}")  # (100, 3)

# 각 센서별 평균 계산
sensor_means = np.mean(all_sensors, axis=0)
print(f"센서별 평균: {sensor_means}")
```

---

## 14. 요약

### 14.1 핵심 개념

1. **배열 생성**: `np.array()`, `np.zeros()`, `np.ones()`, `np.arange()`, `np.linspace()` 등
2. **배열 속성**: `shape`, `dtype`, `size`, `ndim`, `itemsize`, `nbytes`
3. **인덱싱**: 단일 인덱싱, 슬라이싱, 불리언 인덱싱, 팬시 인덱싱
4. **연산**: 벡터화 연산, 브로드캐스팅, 수학 함수
5. **변형**: `reshape()`, `transpose()`, `flatten()`, `expand_dims()`
6. **결합/분할**: `concatenate()`, `vstack()`, `hstack()`, `split()`
7. **통계**: `mean()`, `std()`, `sum()`, `min()`, `max()`, `percentile()`
8. **선형대수**: `dot()`, `inv()`, `det()`, `eig()`, `solve()`
9. **난수**: `random.random()`, `random.randint()`, `random.normal()`
10. **유틸리티**: `where()`, `unique()`, `sort()`, `argsort()`, `meshgrid()`

### 14.2 성능 팁

- **벡터화**: 반복문 대신 배열 연산 사용
- **브로드캐스팅**: 메모리 효율적인 연산
- **뷰 vs 복사**: `reshape()`, `ravel()`은 뷰를 반환하지만 `flatten()`은 복사
- **적절한 dtype 사용**: 메모리 사용량 최적화

### 14.3 주의사항

- **메모리**: 큰 배열을 다룰 때는 메모리 사용량 주의
- **dtype**: 연산 결과의 dtype이 예상과 다를 수 있음
- **브로드캐스팅 규칙**: 차원이 맞지 않으면 오류 발생 가능
- **인덱싱**: 슬라이싱은 뷰를 반환하지만, 정수 배열 인덱싱은 복사본 반환

### 14.4 다음 단계

- **Pandas**: NumPy 기반의 데이터 분석 라이브러리
- **Matplotlib**: NumPy 배열을 이용한 시각화
- **SciPy**: NumPy 기반의 과학 계산 라이브러리
- **Scikit-learn**: NumPy 배열을 이용한 머신러닝

---

**참고 자료**:
- [NumPy 공식 문서](https://numpy.org/doc/stable/)
- [NumPy 튜토리얼](https://numpy.org/doc/stable/user/quickstart.html)

