---
tags:
  - knowledge/topic
Source: [[GitHub_Study_Python]]
---

# 리스트 컴프리헨션과 zip, 언패킹 조합 문법

## 📖 정의 (Definition)
**리스트 컴프리헨션(List Comprehension)**은 기존 이터러블을 기반으로 새로운 리스트를 간결하게 생성하는 파이썬 고유의 문법이며, **zip()**과 **언패킹**을 조합하면 복잡한 데이터 변환 작업을 매우 효율적이고 직관적으로 처리할 수 있습니다.

---

## 목차

1. [리스트 컴프리헨션 기본 개념](#1-리스트-컴프리헨션-기본-개념)
2. [언패킹(Unpacking) 개념](#2-언패킹unpacking-개념)
3. [zip() 함수 개념](#3-zip-함수-개념)
4. [리스트 컴프리헨션과 언패킹 조합](#4-리스트-컴프리헨션과-언패킹-조합)
5. [리스트 컴프리헨션, 언패킹, zip 조합](#5-리스트-컴프리헨션-언패킹-zip-조합)
6. [전통적인 방법과 비교](#6-전통적인-방법과-비교)
7. [다양한 활용 예제](#7-다양한-활용-예제)
8. [중첩 구조 이해](#8-중첩-구조-이해)
9. [주의사항](#9-주의사항)
10. [다른 데이터 구조로 변환](#10-다른-데이터-구조로-변환)
11. [성능 고려사항](#11-성능-고려사항)
12. [실전 활용 패턴](#12-실전-활용-패턴)
13. [요약](#13-요약)

---

## 1. 리스트 컴프리헨션 기본 개념

### 1.1 리스트 컴프리헨션이란?

**리스트 컴프리헨션(List Comprehension)**은 기존 이터러블(리스트, 튜플 등)을 기반으로 새로운 리스트를 간결하게 생성하는 파이썬의 문법입니다.

#### 정의
- **컴프리헨션(Comprehension)**: "이해하다", "포함하다"라는 의미
- 기존 데이터를 **이해**하고, 새로운 리스트에 **포함**시키는 과정을 한 줄로 표현
- for 루프와 append를 사용하는 전통적인 방법을 간결하게 표현한 것

#### 왜 사용하는가?

```python
# 전통적인 방법
numbers = [1, 2, 3, 4, 5]
squared = []
for x in numbers:
    squared.append(x**2)

# 리스트 컴프리헨션 (간결하고 읽기 쉬움)
squared = [x**2 for x in numbers]
```

**장점:**
- ✅ 코드가 간결하고 읽기 쉬움
- ✅ 의도가 명확함 (리스트를 생성한다는 것이 바로 드러남)
- ✅ 성능이 약간 더 좋음 (내부적으로 최적화됨)
- ✅ 파이썬다운(Pythonic) 코드 스타일

### 1.2 기본 원리와 구조

#### 기본 문법 구조

```python
[표현식 for 항목 in 이터러블]
```

**구성 요소:**
1. **`[ ]`**: 리스트를 생성한다는 의미
2. **표현식**: 각 항목에 대해 계산할 식
3. **`for 항목 in 이터러블`**: 반복문 부분

#### 실행 과정 이해

```python
numbers = [1, 2, 3, 4, 5]
squared = [x**2 for x in numbers]

# 실행 과정:
# 1. numbers 리스트의 각 요소를 x에 할당
# 2. x**2를 계산
# 3. 계산 결과를 새 리스트에 추가
# 4. 모든 요소 처리 후 리스트 반환
```

#### for 루프와의 비교

```python
numbers = [1, 2, 3, 4, 5]

# 방법 1: 전통적인 for 루프
squared = []
for x in numbers:
    squared.append(x**2)

# 방법 2: 리스트 컴프리헨션 (동일한 결과)
squared = [x**2 for x in numbers]

# 두 방법 모두 결과: [1, 4, 9, 16, 25]
```

**차이점:**
- 리스트 컴프리헨션은 **선언적(declarative)**: "무엇을 만들 것인가"에 집중
- for 루프는 **명령적(imperative)**: "어떻게 만들 것인가"에 집중

### 1.3 기본 문법 예제

#### 예제 1: 숫자 변환

```python
# 기본 형식
[표현식 for 항목 in 이터러블]

# 예제: 제곱 계산
numbers = [1, 2, 3, 4, 5]
squared = [x**2 for x in numbers]
print(squared)  # [1, 4, 9, 16, 25]
```

#### 예제 2: 문자열 변환

```python
# 문자열 리스트 변환
names = ['홍길동', '김철수', '이영희']
upper_names = [name.upper() for name in names]
print(upper_names)  # ['홍길동', '김철수', '이영희']
```

#### 예제 3: 타입 변환

```python
# 문자열을 정수로 변환
str_numbers = ['1', '2', '3', '4', '5']
int_numbers = [int(x) for x in str_numbers]
print(int_numbers)  # [1, 2, 3, 4, 5]
```

#### 예제 4: 복잡한 표현식

```python
# 여러 연산 조합
numbers = [1, 2, 3, 4, 5]
result = [x**2 + 10 for x in numbers]
print(result)  # [11, 14, 19, 26, 35]
```

### 1.4 조건문 포함 (if 필터링)

#### 기본 문법

```python
[표현식 for 항목 in 이터러블 if 조건]
```

**실행 순서:**
1. 이터러블에서 항목을 하나씩 가져옴
2. 조건을 확인
3. 조건이 True인 경우에만 표현식 실행
4. 결과를 리스트에 추가

#### 예제 1: 짝수만 필터링

```python
numbers = [1, 2, 3, 4, 5]
even_squared = [x**2 for x in numbers if x % 2 == 0]
print(even_squared)  # [4, 16]

# 실행 과정:
# x=1: 1 % 2 == 0 → False → 제외
# x=2: 2 % 2 == 0 → True → 2**2 = 4 추가
# x=3: 3 % 2 == 0 → False → 제외
# x=4: 4 % 2 == 0 → True → 4**2 = 16 추가
# x=5: 5 % 2 == 0 → False → 제외
```

#### 예제 2: 조건부 변환

```python
# 80점 이상만 선택
scores = [65, 85, 92, 78, 95]
high_scores = [score for score in scores if score >= 80]
print(high_scores)  # [85, 92, 95]
```

#### 예제 3: 문자열 필터링

```python
words = ['apple', 'banana', 'cherry', 'date']
long_words = [word for word in words if len(word) > 5]
print(long_words)  # ['banana', 'cherry']
```

### 1.5 중첩 리스트 컴프리헨션

#### 기본 구조

```python
[표현식 for 항목1 in 이터러블1 for 항목2 in 이터러블2]
```

#### 예제: 곱셈표 생성

```python
# 2x2 곱셈표
table = [[i * j for j in range(1, 4)] for i in range(1, 4)]
print(table)
# [[1, 2, 3], [2, 4, 6], [3, 6, 9]]

# 전통적인 방법과 비교
table = []
for i in range(1, 4):
    row = []
    for j in range(1, 4):
        row.append(i * j)
    table.append(row)
```

#### 평탄화(Flatten) 예제

```python
# 중첩 리스트를 평탄화
nested = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flattened = [item for sublist in nested for item in sublist]
print(flattened)  # [1, 2, 3, 4, 5, 6, 7, 8, 9]
```

### 1.6 조건부 표현식 (삼항 연산자) 사용

#### 기본 구조

```python
[표현식1 if 조건 else 표현식2 for 항목 in 이터러블]
```

#### 예제: 조건에 따라 다른 값 할당

```python
# 점수에 따라 등급 부여
scores = [85, 92, 78, 65, 95]
grades = ['A' if s >= 90 else 'B' if s >= 80 else 'C' for s in scores]
print(grades)  # ['B', 'A', 'C', 'C', 'A']
```

#### 예제: 양수/음수 구분

```python
numbers = [-2, -1, 0, 1, 2]
signs = ['양수' if x > 0 else '음수' if x < 0 else '영' for x in numbers]
print(signs)  # ['음수', '음수', '영', '양수', '양수']
```

### 1.7 다양한 이터러블 사용

#### range() 사용

```python
# range를 사용한 리스트 생성
squares = [x**2 for x in range(1, 6)]
print(squares)  # [1, 4, 9, 16, 25]
```

#### 문자열 사용

```python
# 문자열의 각 문자 처리
text = "hello"
chars = [char.upper() for char in text]
print(chars)  # ['H', 'E', 'L', 'L', 'O']
```

#### 딕셔너리 사용

```python
# 딕셔너리의 키나 값 사용
person = {'name': '홍길동', 'age': 25, 'city': '서울'}
keys = [key for key in person.keys()]
values = [value for value in person.values()]
print(keys)    # ['name', 'age', 'city']
print(values)  # ['홍길동', 25, '서울']
```

### 1.8 리스트 컴프리헨션의 한계

#### 복잡한 로직은 피하기

```python
# 좋은 예: 간단하고 명확한 변환
squared = [x**2 for x in range(10)]

# 나쁜 예: 너무 복잡한 로직 (일반 for 루프가 더 나음)
result = [
    complex_calculation(x, y, z) 
    for x in range(10) 
    for y in range(10) 
    for z in range(10) 
    if condition1(x) and condition2(y) and condition3(z)
]

# 이런 경우는 일반 for 루프가 더 읽기 쉬움
```

#### 부수 효과(Side Effect) 피하기

```python
# 나쁜 예: 리스트 컴프리헨션에서 print 사용
# [print(x) for x in range(5)]  # 작동하지만 권장하지 않음

# 좋은 예: 일반 for 루프 사용
for x in range(5):
    print(x)
```

### 1.9 요약: 리스트 컴프리헨션 핵심

**기본 구조:**
```python
[표현식 for 항목 in 이터러블]
[표현식 for 항목 in 이터러블 if 조건]
[표현식1 if 조건 else 표현식2 for 항목 in 이터러블]
```

**핵심 개념:**
- ✅ 기존 이터러블을 기반으로 새 리스트 생성
- ✅ for 루프와 append를 간결하게 표현
- ✅ 선언적 프로그래밍 스타일
- ✅ 간단한 변환과 필터링에 적합
- ⚠️ 복잡한 로직은 일반 for 루프 고려

## 2. 언패킹(Unpacking) 개념

### 2.1 언패킹이란?

**언패킹(Unpacking)**은 컬렉션(리스트, 튜플 등)의 요소를 개별 변수로 풀어내는 파이썬의 기능입니다.

#### 기본 개념

```python
# 튜플 언패킹
point = (3, 4)
x, y = point
print(x, y)  # 3 4

# 리스트 언패킹
numbers = [1, 2, 3]
a, b, c = numbers
print(a, b, c)  # 1 2 3
```

**언패킹의 장점:**
- ✅ 여러 값을 한 번에 할당 가능
- ✅ 코드가 간결하고 읽기 쉬움
- ✅ 튜플/리스트의 요소를 직접 변수로 사용 가능

### 2.2 기본 언패킹 예제

#### 튜플 언패킹

```python
# 기본 튜플 언패킹
coordinates = (10, 20)
x, y = coordinates
print(f"x={x}, y={y}")  # x=10, y=20

# 여러 튜플 언패킹
point1 = (1, 2)
point2 = (3, 4)
x1, y1 = point1
x2, y2 = point2
```

#### 리스트 언패킹

```python
# 리스트 언패킹
data = ['홍길동', 25, '서울']
name, age, city = data
print(f"{name}은 {age}세, {city}에 살고 있습니다.")
```

#### 여러 변수에 한 번에 할당

```python
# 여러 값을 한 번에 언패킹
a, b, c = 1, 2, 3
print(a, b, c)  # 1 2 3

# 함수 반환값 언패킹
def get_name_age():
    return '홍길동', 25

name, age = get_name_age()
print(name, age)  # 홍길동 25
```

### 2.3 언패킹 연산자 (*)

#### 기본 사용법

```python
# * 연산자로 나머지 요소 언패킹
numbers = [1, 2, 3, 4, 5]
first, *middle, last = numbers
print(first)    # 1
print(middle)   # [2, 3, 4]
print(last)     # 5
```

#### 다양한 패턴

```python
# 앞부분만 언패킹
*rest, last = [1, 2, 3, 4, 5]
print(rest)  # [1, 2, 3, 4]
print(last)  # 5

# 뒷부분만 언패킹
first, *rest = [1, 2, 3, 4, 5]
print(first)  # 1
print(rest)   # [2, 3, 4, 5]

# 중간 부분 언패킹
first, *middle, last = [1, 2, 3, 4, 5]
print(first)   # 1
print(middle)  # [2, 3, 4]
print(last)    # 5
```

#### 함수 인자로 언패킹

```python
# 함수 인자로 언패킹
def add(a, b, c):
    return a + b + c

numbers = [1, 2, 3]
result = add(*numbers)  # add(1, 2, 3)과 동일
print(result)  # 6

# 딕셔너리 언패킹
def greet(name, age, city):
    return f"{name}은 {age}세, {city}에 살고 있습니다."

person = {'name': '홍길동', 'age': 25, 'city': '서울'}
result = greet(**person)  # 키워드 인자로 언패킹
print(result)  # 홍길동은 25세, 서울에 살고 있습니다.
```

### 2.4 리스트 컴프리헨션에서 언패킹 사용

리스트 컴프리헨션에서 언패킹을 사용하면 튜플이나 리스트의 요소를 개별 변수로 분리하여 사용할 수 있습니다. 자세한 내용은 섹션 4를 참고하세요.

### 2.5 언패킹의 실전 활용

#### for 루프에서 언패킹

```python
# 튜플 리스트 순회
students = [('홍길동', 85), ('김철수', 92), ('이영희', 78)]
for name, score in students:
    print(f"{name}: {score}점")

# 딕셔너리 items() 순회
person = {'name': '홍길동', 'age': 25, 'city': '서울'}
for key, value in person.items():
    print(f"{key}: {value}")
```

#### enumerate와 언패킹

```python
# enumerate와 함께 사용
names = ['홍길동', '김철수', '이영희']
for index, name in enumerate(names):
    print(f"{index}: {name}")
# 출력:
# 0: 홍길동
# 1: 김철수
# 2: 이영희
```

### 2.6 언패킹 주의사항

#### 요소 개수 불일치

```python
# 요소 개수가 맞지 않으면 에러 발생
point = (3, 4)
# x, y, z = point  # ValueError: not enough values to unpack

# 해결책: * 연산자 사용
x, y, *rest = point
print(x, y)    # 3 4
print(rest)    # []
```

#### 중첩 구조 언패킹

```python
# 중첩된 구조 언패킹
nested = [(1, 2), (3, 4), (5, 6)]
for x, y in nested:
    print(x, y)

# 더 복잡한 중첩
complex_data = [((1, 2), 3), ((4, 5), 6)]
for (x, y), z in complex_data:
    print(x, y, z)
```

## 3. zip() 함수 개념

### 3.1 zip() 함수란?

`zip()` 함수는 여러 개의 이터러블(리스트, 튜플 등)을 병렬로 묶어서 튜플의 이터레이터를 반환합니다.

#### 기본 사용법

```python
# 기본 예제
l1 = [1, 2, 3, 4, 5]
l2 = [6, 7, 8, 9, 10]

# zip 객체 반환 (직접 출력하면 메모리 주소만 보임)
zipped = zip(l1, l2)
print(zipped)  # <zip object at 0x...>

# 리스트로 변환하여 확인
print(list(zipped))  # [(1, 6), (2, 7), (3, 8), (4, 9), (5, 10)]
```

### 3.2 zip() 함수의 특징

#### 1. 가장 짧은 이터러블 길이에 맞춤

```python
l1 = [1, 2, 3]
l2 = [4, 5, 6, 7, 8]
print(list(zip(l1, l2)))  # [(1, 4), (2, 5), (3, 6)] - 3개만!
```

#### 2. 여러 개의 이터러블 동시 처리 가능

```python
l1 = [1, 2, 3]
l2 = [4, 5, 6]
l3 = [11, 12, 13]
print(list(zip(l1, l2, l3)))  # [(1, 4, 11), (2, 5, 12), (3, 6, 13)]
```

### 3.3 zip()과 언패킹 조합

zip 결과를 언패킹하여 사용하면 튜플 인덱싱 없이 직접 변수로 사용할 수 있습니다.

```python
# zip 결과를 언패킹하여 사용
l1 = [1, 2, 3]
l2 = [4, 5, 6]

for x, y in zip(l1, l2):
    print(f"x={x}, y={y}")
# 출력:
# x=1, y=4
# x=2, y=5
# x=3, y=6
```

### 3.4 zip()의 실전 활용

#### 두 리스트를 딕셔너리로 변환

```python
keys = ['name', 'age', 'city']
values = ['홍길동', 25, '서울']
person = dict(zip(keys, values))
print(person)  # {'name': '홍길동', 'age': 25, 'city': '서울'}
```

#### 리스트 전치(행과 열 바꾸기)

```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
transposed = list(zip(*matrix))
print(transposed)  # [(1, 4, 7), (2, 5, 8), (3, 6, 9)]
```

#### 여러 리스트를 동시에 순회

```python
names = ['홍길동', '김철수', '이영희']
ages = [25, 30, 28]
cities = ['서울', '부산', '대구']

for name, age, city in zip(names, ages, cities):
    print(f"{name}은(는) {age}세이고 {city}에 살고 있습니다.")
```

#### zip으로 묶은 후 다시 분리하기

```python
l1 = [1, 2, 3]
l2 = [4, 5, 6]

zipped = list(zip(l1, l2))
print(zipped)  # [(1, 4), (2, 5), (3, 6)]

# 언패킹으로 다시 분리
unzipped_l1, unzipped_l2 = zip(*zipped)
print(list(unzipped_l1))  # [1, 2, 3]
print(list(unzipped_l2))  # [4, 5, 6]
```

#### 딕셔너리와 zip 활용

```python
# 딕셔너리의 키와 값을 zip으로 묶기
d1 = {'a': 1, 'b': 2, 'c': 3}
print(list(zip(d1.keys(), d1.values())))  # [('a', 1), ('b', 2), ('c', 3)]

# items() 메서드와 동일한 결과
print(list(d1.items()))  # [('a', 1), ('b', 2), ('c', 3)]
```

### 3.5 zip() 주의사항

#### zip 객체는 한 번만 사용 가능

```python
l1 = [1, 2, 3]
l2 = [4, 5, 6]
zipped = zip(l1, l2)

print(list(zipped))  # [(1, 4), (2, 5), (3, 6)]
print(list(zipped))  # [] - 이미 소비됨!

# 해결책: 리스트로 변환하여 저장
zipped_list = list(zip(l1, l2))
print(list(zipped_list))  # [(1, 4), (2, 5), (3, 6)]
print(list(zipped_list))  # [(1, 4), (2, 5), (3, 6)] - 재사용 가능
```

#### 길이가 다른 경우 주의

```python
# 기본 zip은 짧은 길이에 맞춤
l1 = [1, 2, 3]
l2 = [4, 5, 6, 7, 8]
print(list(zip(l1, l2)))  # [(1, 4), (2, 5), (3, 6)] - 7, 8은 무시됨

# itertools.zip_longest 사용하면 긴 것에 맞춤
from itertools import zip_longest

print(list(zip_longest(l1, l2, fillvalue=0)))
# [(1, 4), (2, 5), (3, 6), (0, 7), (0, 8)]
```

#### 빈 이터러블 처리

```python
# 빈 리스트와 zip하면 빈 결과 반환
l1 = []
l2 = [1, 2, 3]
print(list(zip(l1, l2)))  # []
```

## 4. 리스트 컴프리헨션과 언패킹 조합

### 4.1 기본 조합

리스트 컴프리헨션에서 언패킹을 사용하면 튜플이나 리스트의 요소를 개별 변수로 분리하여 사용할 수 있습니다.

```python
# 튜플 리스트에서 언패킹하여 리스트 컴프리헨션 사용
pairs = [(1, 2), (3, 4), (5, 6)]
sums = [x + y for x, y in pairs]
print(sums)  # [3, 7, 11]

# 실행 과정:
# (1, 2) → x=1, y=2 → 1+2=3
# (3, 4) → x=3, y=4 → 3+4=7
# (5, 6) → x=5, y=6 → 5+6=11
```

### 4.2 딕셔너리 items()와 조합

```python
# 딕셔너리에서 키-값 쌍 언패킹
person = {'name': '홍길동', 'age': 25, 'city': '서울'}
info_list = [f"{key}: {value}" for key, value in person.items()]
print(info_list)
# ['name: 홍길동', 'age: 25', 'city: 서울']
```

### 4.3 여러 변수 언패킹

```python
# 세 개 이상의 값 언패킹
triples = [(1, 2, 3), (4, 5, 6), (7, 8, 9)]
products = [x * y * z for x, y, z in triples]
print(products)  # [6, 120, 504]
```

## 5. 리스트 컴프리헨션, 언패킹, zip 조합

### 5.1 문법 개요

```python
[{'name': n, 'score': s} for n, s in zip(names, scores)]
```

이 문법은 다음 세 가지 개념이 결합된 것입니다:
1. **리스트 컴프리헨션** (List Comprehension)
2. **zip() 함수**
3. **언패킹(Unpacking)**

### 5.2 전체 구조 분해

```python
# 원본 코드
[{'name': n, 'score': s} for n, s in zip(names, scores)]

# 구조 분석
[                    # 1. 리스트 컴프리헨션 시작
    {'name': n, 'score': s}  # 2. 각 반복에서 생성할 딕셔너리
    for n, s in zip(names, scores)  # 3. zip과 언패킹을 사용한 반복
]                    # 4. 리스트 컴프리헨션 종료
```

### 5.3 단계별 이해

#### 단계 1: zip() 함수 실행

```python
names = ['홍길동', '김철수', '이영희']
scores = [85, 92, 78]

# zip으로 묶기
zipped = zip(names, scores)
print(list(zipped))  # [('홍길동', 85), ('김철수', 92), ('이영희', 78)]
```

#### 단계 2: 언패킹으로 각 튜플 분해

```python
# zip 결과를 순회하면서 언패킹
for n, s in zip(names, scores):
    print(f"n={n}, s={s}")
# 출력:
# n=홍길동, s=85
# n=김철수, s=92
# n=이영희, s=78
```

#### 단계 3: 딕셔너리 생성

```python
# 각 반복에서 딕셔너리 생성
for n, s in zip(names, scores):
    student = {'name': n, 'score': s}
    print(student)
# 출력:
# {'name': '홍길동', 'score': 85}
# {'name': '김철수', 'score': 92}
# {'name': '이영희', 'score': 78}
```

#### 단계 4: 리스트 컴프리헨션으로 결합

```python
# 위의 과정을 한 줄로 표현
students = [{'name': n, 'score': s} for n, s in zip(names, scores)]
print(students)
# [{'name': '홍길동', 'score': 85}, {'name': '김철수', 'score': 92}, {'name': '이영희', 'score': 78}]
```

## 6. 전통적인 방법과 비교

### 6.1 전통적인 for 루프 방식

```python
names = ['홍길동', '김철수', '이영희']
scores = [85, 92, 78]

# 방법 1: 인덱스 사용
students = []
for i in range(len(names)):
    student = {'name': names[i], 'score': scores[i]}
    students.append(student)

# 방법 2: enumerate 사용
students = []
for i, name in enumerate(names):
    student = {'name': name, 'score': scores[i]}
    students.append(student)

# 방법 3: zip 사용 (가장 깔끔한 전통 방식)
students = []
for name, score in zip(names, scores):
    student = {'name': name, 'score': score}
    students.append(student)
```

### 6.2 리스트 컴프리헨션 방식 (권장)

```python
# 한 줄로 간결하게 표현
students = [{'name': n, 'score': s} for n, s in zip(names, scores)]
```

**장점:**
- 코드가 간결하고 읽기 쉬움
- 성능이 약간 더 좋음 (내부 최적화)
- 파이썬다운(Pythonic) 코드 스타일

## 7. 다양한 활용 예제

### 7.1 기본 예제

```python
names = ['홍길동', '김철수', '이영희']
scores = [85, 92, 78]

students = [{'name': n, 'score': s} for n, s in zip(names, scores)]
print(students)
# [{'name': '홍길동', 'score': 85}, {'name': '김철수', 'score': 92}, {'name': '이영희', 'score': 78}]
```

### 7.2 여러 필드 추가

```python
names = ['홍길동', '김철수', '이영희']
scores = [85, 92, 78]
ages = [20, 21, 19]

students = [
    {'name': n, 'score': s, 'age': a} 
    for n, s, a in zip(names, scores, ages)
]
print(students)
# [{'name': '홍길동', 'score': 85, 'age': 20}, ...]
```

### 7.3 조건부 필터링

```python
names = ['홍길동', '김철수', '이영희']
scores = [85, 92, 78]

# 80점 이상만 선택
high_scores = [
    {'name': n, 'score': s} 
    for n, s in zip(names, scores) 
    if s >= 80
]
print(high_scores)
# [{'name': '홍길동', 'score': 85}, {'name': '김철수', 'score': 92}]
```

### 7.4 계산된 값 추가

```python
names = ['홍길동', '김철수', '이영희']
scores = [85, 92, 78]

# 등급 계산하여 추가
students = [
    {
        'name': n, 
        'score': s, 
        'grade': 'A' if s >= 90 else 'B' if s >= 80 else 'C'
    } 
    for n, s in zip(names, scores)
]
print(students)
# [{'name': '홍길동', 'score': 85, 'grade': 'B'}, ...]
```

### 7.5 딕셔너리 키를 변수로 사용

```python
# 키 이름도 동적으로 생성
names = ['홍길동', '김철수', '이영희']
scores = [85, 92, 78]

students = [
    {f'student_{i}_name': n, f'student_{i}_score': s}
    for i, (n, s) in enumerate(zip(names, scores))
]
print(students)
# [{'student_0_name': '홍길동', 'student_0_score': 85}, ...]
```

## 8. 중첩 구조 이해

### 8.1 실행 순서

```python
# [{'name': n, 'score': s} for n, s in zip(names, scores)]
# 
# 실행 순서:
# 1. zip(names, scores) 실행 → 이터레이터 생성
# 2. 각 튜플 (n, s) 언패킹
# 3. {'name': n, 'score': s} 딕셔너리 생성
# 4. 생성된 딕셔너리를 리스트에 추가
# 5. 모든 요소 처리 후 리스트 반환
```

### 8.2 단계별 시각화

```python
names = ['홍길동', '김철수']
scores = [85, 92]

# 단계별로 보면:
# 반복 1: n='홍길동', s=85 → {'name': '홍길동', 'score': 85}
# 반복 2: n='김철수', s=92 → {'name': '김철수', 'score': 92}
# 결과: [{'name': '홍길동', 'score': 85}, {'name': '김철수', 'score': 92}]
```

## 9. 주의사항

### 9.1 변수명 선택

```python
# 변수명은 의미있게 선택하는 것이 좋음
names = ['홍길동', '김철수']
scores = [85, 92]

# 좋은 예
students = [{'name': name, 'score': score} for name, score in zip(names, scores)]

# 나쁜 예 (의미 없는 변수명)
students = [{'name': n, 'score': s} for n, s in zip(names, scores)]  # 짧은 코드에서는 괜찮지만
```

### 9.2 길이가 다른 경우

```python
names = ['홍길동', '김철수', '이영희']
scores = [85, 92]  # 길이가 다름

# zip은 짧은 것에 맞춤 (섹션 3.5 참고)
students = [{'name': n, 'score': s} for n, s in zip(names, scores)]
print(students)
# [{'name': '홍길동', 'score': 85}, {'name': '김철수', 'score': 92}]
# '이영희'는 무시됨!
```

### 9.3 빈 리스트 처리

```python
names = []
scores = []

# 빈 리스트면 빈 결과 반환
students = [{'name': n, 'score': s} for n, s in zip(names, scores)]
print(students)  # []
```

## 10. 다른 데이터 구조로 변환

### 10.1 튜플 리스트로 변환

```python
names = ['홍길동', '김철수', '이영희']
scores = [85, 92, 78]

# 딕셔너리 대신 튜플 사용
students = [(n, s) for n, s in zip(names, scores)]
print(students)  # [('홍길동', 85), ('김철수', 92), ('이영희', 78)]
```

### 10.2 딕셔너리로 변환 (키-값 쌍)

```python
names = ['홍길동', '김철수', '이영희']
scores = [85, 92, 78]

# 딕셔너리 컴프리헨션 사용
students = {n: s for n, s in zip(names, scores)}
print(students)  # {'홍길동': 85, '김철수': 92, '이영희': 78}
```

### 10.3 집합으로 변환

```python
names = ['홍길동', '김철수', '홍길동']  # 중복 있음
scores = [85, 92, 90]

# 집합 컴프리헨션 (중복 제거)
unique_scores = {s for n, s in zip(names, scores)}
print(unique_scores)  # {85, 92, 90}
```

## 11. 성능 고려사항

### 11.1 메모리 효율성

```python
# 리스트 컴프리헨션은 전체 리스트를 메모리에 생성
names = ['홍길동'] * 1000000
scores = [85] * 1000000

# 메모리에 전체 리스트가 생성됨
students = [{'name': n, 'score': s} for n, s in zip(names, scores)]

# 제너레이터 표현식 사용하면 메모리 효율적 (한 번에 하나씩만 처리)
students_gen = ({'name': n, 'score': s} for n, s in zip(names, scores))
# 필요할 때만 하나씩 생성
```

### 11.2 가독성 vs 성능

```python
# 간단한 경우: 리스트 컴프리헨션 권장
students = [{'name': n, 'score': s} for n, s in zip(names, scores)]

# 복잡한 경우: 일반 for 루프가 더 읽기 쉬울 수 있음
students = []
for name, score in zip(names, scores):
    if score >= 80:
        student = {
            'name': name,
            'score': score,
            'grade': calculate_grade(score),
            'status': 'pass' if score >= 70 else 'fail'
        }
        students.append(student)
```

## 12. 실전 활용 패턴

### 12.1 CSV 데이터 변환

```python
# CSV 형태의 데이터를 딕셔너리 리스트로 변환
headers = ['name', 'age', 'city']
rows = [
    ['홍길동', 25, '서울'],
    ['김철수', 30, '부산'],
    ['이영희', 28, '대구']
]

# 각 행을 딕셔너리로 변환
data = [
    {header: value for header, value in zip(headers, row)}
    for row in rows
]
print(data)
# [{'name': '홍길동', 'age': 25, 'city': '서울'}, ...]
```

### 12.2 API 응답 데이터 변환

```python
# API에서 받은 데이터를 원하는 형식으로 변환
user_ids = [1, 2, 3]
user_names = ['홍길동', '김철수', '이영희']
user_emails = ['hong@example.com', 'kim@example.com', 'lee@example.com']

users = [
    {
        'id': uid,
        'name': name,
        'email': email,
        'display_name': f"{name} ({email})"
    }
    for uid, name, email in zip(user_ids, user_names, user_emails)
]
```

### 12.3 데이터 정규화

```python
# 여러 리스트를 하나의 구조화된 데이터로 변환
products = ['노트북', '마우스', '키보드']
prices = [1000000, 30000, 50000]
stocks = [10, 50, 30]

inventory = [
    {
        'product': p,
        'price': price,
        'stock': stock,
        'total_value': price * stock
    }
    for p, price, stock in zip(products, prices, stocks)
]
```

## 13. 요약

### 핵심 개념

```python
[{'name': n, 'score': s} for n, s in zip(names, scores)]
```

이 문법은:
1. **zip(names, scores)**: 두 리스트를 병렬로 묶어 튜플 이터레이터 생성
2. **for n, s in**: 각 튜플을 언패킹하여 n과 s 변수에 할당
3. **{'name': n, 'score': s}**: 각 반복에서 딕셔너리 생성
4. **[ ... ]**: 리스트 컴프리헨션으로 모든 딕셔너리를 리스트로 수집

### 언제 사용하는가?

- ✅ 여러 리스트를 하나의 구조화된 데이터로 변환할 때
- ✅ 인덱스 없이 깔끔하게 데이터를 처리할 때
- ✅ 간결하고 읽기 쉬운 코드를 작성할 때
- ✅ 파이썬다운(Pythonic) 스타일을 유지할 때

### 주의할 점

- ⚠️ 리스트 길이가 다르면 짧은 것에 맞춰짐
- ⚠️ 복잡한 로직은 일반 for 루프가 더 읽기 쉬울 수 있음
- ⚠️ 큰 데이터셋은 제너레이터 표현식 고려
