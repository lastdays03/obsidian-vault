# 아키텍처 비교 가이드: 모노리스 vs MSA vs 서버리스

**태그**: #knowledge/map #topic/Architecture #topic/Strategy
**업데이트**: 2026-01-26

---

## 🏗️ 3원 아키텍처 한눈에 비교

| 항목 | 모노리스 (Monolith) | 마이크로서비스 (MSA) | 서버리스 (Serverless) |
| :--- | :--- | :--- | :--- |
| **코드베이스** | 단일 프로젝트 / 단일 배포 | 여러 개의 독립 서비스 | 함수 단위 (FaaS) |
| **인프라 관리** | 직접 관리 (VM, 컨테이너) | 직접 관리 (K8s 등 복잡) | 거의 없음 (클라우드 전담) |
| **스케일링** | 전체 애플리케이션 단위 | 서비스별 개별 스케일 | 함수별 무한 자동 스케일 |
| **비용 모델** | 상시 가동 비용 (고정비) | 상시 + 스케일 비용 | **진짜 사용량 기반 (Pay-per-use)** |
| **운영 복잡도** | ★ 낮음 | ★★★★ 매우 높음 | ★★ 중간 (콜드스타트 관리) |
| **초기 속도** | ★★★★★ 가장 빠름 | ★★ 느림 (인프라 구축) | ★★★★ 빠름 (코드 집중) |
| **장점** | 개발/디버깅 단순함 | 높은 확장성, 팀 자율성 | 운영 관리 제로, 비용 효율 |
| **단점** | 규모 커지면 유지보수 지옥 | 분산 시스템 복잡도 폭증 | 콜드 스타트, 벤더 락인 |

---

## ⚖️ 상세 비교 분석 (2025~2026 실무 관점)

### 1. 비용 및 운영 효율
- **서버리스**는 사용하지 않을 때 비용이 **0원**이므로 간헐적 트래픽이나 배치 작업에 압도적으로 유리합니다.
- **MSA**는 서비스마다 인프라 오버헤드가 발생하므로 SRE/DevOps 팀의 지원 없이 도입하면 운영 비용이 폭증합니다.

### 2. 개발 및 유지보수성
- **모노리스**는 IDE 하나에서 모든 흐름을 파악할 수 있어 초기 생산성이 가장 높습니다.
- **서버리스**는 함수가 너무 많아지면 전체 흐름을 파악하기 어려워지는 "람다 스파게티" 위험이 있습니다.

---

## 🚀 2025~2026 현실적인 선택 가이드

많은 성공적인 기술 조직들이 따르는 로드맵입니다.

| 상황 / 목표 | 추천 선택 (1순위 → 3순위) | 전략 및 트렌드 |
| :--- | :--- | :--- |
| **스타트업 MVP** | **모노리스** → 서버리스 → MSA | 90% 이상이 여전히 모노리스로 시작 |
| **간헐적/배치 작업** | **서버리스** → 모노리스 → MSA | 비용 70~90% 절감 가능 사례 다수 |
| **AI/ML 추론 백엔드** | **서버리스** → MSA (GPU) → 모노리스 | 2026년 가장 핫한 서버리스 사용처 |
| **대규모 사용자 (DAU 100만↑)** | **MSA** → 서버리스 혼합 → 모듈형 모놀 | 조직의 확장성(Scalability) 확보가 주 목표 |
| **안정적 실시간 서비스** | **모노리스** or MSA → 서버리스 | 콜드스타트 영향 최소화 필요 |

---

## 🔑 Key Insights (결론)

- **"모듈형 모노리스"의 부활**: 2025년 이후의 트렌드는 무조건적인 MSA 분산보다는, 내부 경계가 잘 나누어진 모노리스로 시작하여 꼭 필요한 부분만 서버리스나 개별 서비스로 떼어내는 **하이브리드 전략**입니다.
- **아키텍처는 기술이 아닌 조직의 문제**: 마이크로서비스는 서버 부하를 견디기 위한 수단이기보다, **수백 명의 개발자가 서로 충돌 없이 일하기 위한 수단**입니다.

---

## 📖 연결 노트
- [[Monolithic_Architecture]]
- [[Microservices_Architecture]]
- [[Serverless]]
- [[Concepts_MOC]]
