# 개념 (Concept): Monolithic Architecture

**태그**: #knowledge/concept #topic/Architecture
**출처**: User Request

---

## 📖 정의 (Definition)
모노리스(Monolithic Architecture)는 **하나의 단일 애플리케이션**으로 모든 기능을 구현하는 전통적인 소프트웨어 아키텍처입니다.
모든 코드(프론트엔드, 비즈니스 로직, 데이터베이스 접근, 인증, 배포 등)가 **하나의 코드베이스**, **하나의 프로젝트**, **하나의 실행 파일(.jar, .war, exe 등)** 안에 통합되어 있는 형태입니다.
"단일 돌덩이(Monolith)"라는 뜻처럼, 모든 구성 요소가 하나로 뭉쳐져 있습니다.

---

## 🏗 전형적인 구조 (Structure)

일반적으로 **레이어드 아키텍처(Layered Architecture)** 형태를 띱니다. 모든 레이어가 **같은 프로세스** 안에서 동작합니다.

```mermaid
graph TD
    Client[클라이언트] --> Presentation[Presentation Layer (UI/Controller)]
    Presentation --> Business[Business Logic Layer (Service)]
    Business --> DataAccess[Data Access Layer (Repository/DAO)]
    DataAccess --> DB[(Database)]
```

---

## ⚖️ 장점과 단점 (Pros & Cons)

### 장점 (Why use it?)
| 순위 | 장점 | 설명 |
|:---:|:---|:---|
| 1 | **개발 단순함** | 하나의 프로젝트이므로 IDE 하나만 켜면 되며, 디버깅이 매우 편리합니다. |
| 2 | **배포 단순함** | 한 번 빌드하여 한 번에 배포할 수 있습니다. |
| 3 | **트랜잭션 관리** | 단일 DB와 단일 프로세스를 사용하므로 `@Transactional` 하나로 데이터 정합성을 보장하기 쉽습니다. |
| 4 | **초기 속도** | 오버헤드가 적어 스타트업이나 중소규모 프로젝트의 초기 개발 속도가 매우 빠릅니다. |
| 5 | **성능** | 서비스 간 네트워크 호출(RPC/HTTP)이 없고 메모리 내 호출이므로 성능 오버헤드가 거의 없습니다. |

### 단점 (The Pain Points)
| 문제 | 현실적인 고통 |
|:---|:---|
| **코드베이스 거대화** | 코드가 100만 줄을 넘어가면 IDE가 느려지고 파악이 불가능해집니다. |
| **빌드/배포 시간** | 빌드에 10~30분, 배포에 5~15분이 걸리게 되어 애자일한 대응이 어려워집니다. |
| **결합도 문제** | 작은 변경(예: 로그인 로직)이 전체 애플리케이션의 재배포를 요구합니다. |
| **기술 스택 고착** | 특정 모듈만 새로운 기술(예: Spring -> Quarkus)로 도입하기 어렵고 전체를 바꿔야 합니다. |
| **팀 간 충돌** | 많은 개발자가 하나의 저장소를 수정하므로 머지 충돌과 빌드 깨짐이 빈번합니다. |
| **장애 전파** | 한 모듈의 메모리 누수(OOM)가 전체 서비스 다운으로 이어집니다. |
| **스케일링 비효율** | UI 트래픽만 많더라도 전체 애플리케이션(결제, 정산 포함)을 스케일 아웃해야 합니다. |

---

## 🚀 현실적인 진화 단계 (Evolution)

많은 기업들이 다음과 같은 진화 과정을 겪습니다:

1.  **단순 모노리스 (Simple Monolith)**: 초기 ~ 중소규모. 가장 빠르고 효율적인 단계.
2.  **모듈형 모노리스 (Modular Monolith)**: 패키지/모듈로 강하게 분리하고 의존성 규칙을 강제(DDD 경계 설정)하여 복잡도를 관리하는 단계. 나중에 MSA로 분리하기 좋은 상태입니다.
3.  **점진적 분리 (Strangler Pattern)**: 비대해진 시스템에서 중요한 도메인이나 트래픽이 많은 부분을 하나씩 마이크로서비스로 떼어내는 단계.
4.  **마이크로서비스 (Microservices)**: 완전히 분산된 아키텍처 (일부는 여전히 레거시 모노리스로 남을 수 있음).

---

## 🔑 Key Insights
- **"초기에는 천국, 규모 커지면 지옥"**: 프로젝트 규모에 따라 장단점이 극명하게 갈립니다.
- **적정 기술의 선택**: 작은~중간 규모라면 모노리스는 여전히 **가장 합리적인 선택**입니다. 무조건적인 MSA 도입은 오버엔지니어링일 수 있습니다.
- **모듈화의 중요성**: 모듈형 모노리스로 내부 경계를 잘 관리하면, 모노리스의 장점을 유지하면서도 5~10년 이상 지속 가능한 시스템을 만들 수 있습니다.

---

## 📚 References
- User Request & Summary
